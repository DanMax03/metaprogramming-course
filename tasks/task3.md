Задача 3. Очень умный неуказатель
========================

## Подготовка

Освежите в памяти [использование концептов и ограничений](https://en.cppreference.com/w/cpp/language/constraints) и [объектные концепты стандартной библиотеки](https://en.cppreference.com/w/cpp/concepts).

Вспомните, какие есть способы реализации стирания типов.

Вспомните, как в C++ пишутся "коробки" для значений с точки зрения внешнего интерфейса (e.g. `std::optional`, `std::unique_ptr`). Какие операторы необходимо поддерживать? Какие конструкторы необходимо написать?

**Тесты этой задачи не работают в Clang.** Проверялись в GCC 10.1.

## Задача

Реализуйте шаблонный класс, оборачивающий произвольный объект и логирующий обращения к нему.

```c++
template <class T>
class Spy {
public:
    explicit Spy(T);

    T& operator *();
    const T& operator *() const;

    /* unspecified */ operator ->();

    /*
     * if needed (see below):
     *   default constructor
     *   copy and move construction
     *   copy and move assignment
     *   equality operators
     *   destructor
    */

    template <std::invocable<unsigned int> Logger> requires /* see below */
    void setLogger(Logger&& logger);
};
```

Оборачиваемый объект необходимо хранить по значению. На паре справедливо заметили, что называть такие сущности указателями неправильно, поэтому мы будем называть их умными неуказателями.

Если `s` &mdash; значение типа `Spy<T>`,  выражение `s->member` должно приводить к обращению к нестатическому члену `member` оборачиваемого объекта.

#### Логеры

Метод `setLogger` устанавливает логер. После вычисления каждого выражения, содержащего обращения к оборачиваемому объекту через `operator ->`, должен вызываться логер, если он установлен. В качестве аргумента логер принимает количество обращений к объекту при вычислении выражения.

Обращения через `operator *` не логируются.

Если оборачиваемый тип `T` не копируемый, то `Spy<T>` должен поддерживать move-only логеры.

Если в одном выражении происходит обращение к оборачиваемому объекту и изменяется логер, поведение не определено.

Использовать `std::function` в этом задании запрещено.

Поддержка small buffer optimization для логеров: +1 у.е.

#### Сохранение концептов

Будем говорить, что умный неуказатель `W` сохраняет концепт `C`, если для любого типа `T`

1) `T` удовлетворяет `C` &rArr; `W<T>` удовлетворяет `C`,
2) `T` моделирует `C` &rArr; `W<T>` моделирует `C`.

Ваш `Spy` должен сохранять основные объектные концепты: `std::movable`, `std::copyable`, `std::semiregular`, `std::regular`. Для этого можно накладывать дополнительные ограничения на шаблонный аргумент метода `setLogger`.

Операторы сравнения должны сравнивать оборачиваемые объекты, игнорируя логер. При копировании (перемещении) должны копироваться (перемещаться) и логер, и оборачиваемый объект.

Если в одном выражении происходит обращение к оборачиваемому объекту и перемещение неуказателя, поведение не определено. Копирование создаёт новый объект, обращения к которому должны учитываться отдельно.

## Пример

```c++
struct Holder {
    int x = 0;
    bool isPositive() const {
        return x > 0;
    }
};

Spy s{Holder{}};
static_assert(std::semiregular<decltype(s)>);

s.setLogger([](auto n) { std::cout << n << std::endl; });

s->isPositive() && s->x--; // prints 1
s->x++ + s->x++; // prints 2
s->isPositive() && s->x--; // prints 2

s.setLogger([dummy = std::unique_ptr<int>()](auto n) {}); // compilation error

// -----------------------------------

struct MoveOnly {
    MoveOnly() = default;

    MoveOnly(MoveOnly&&) = default;
    MoveOnly& operator =(MoveOnly&&) = default;

    MoveOnly(const MoveOnly&) = delete;
    MoveOnly& operator =(const MoveOnly&) = delete;

    ~MoveOnly() noexcept = default;
};

Spy t{MoveOnly{}};

s.setLogger([dummy = std::unique_ptr<int>()](auto n) {}); // ok

static_assert(std::movable<decltype(t)>);
static_assert(!std::copyable<decltype(t)>);
```

## Вопросы для размышлений

1. С какими проблемами мы бы столкнулись, если бы захотели добавить константную версию оператора `->`?

2. Как бы вы модифицировали класс `Spy`, чтобы поддержать обращения к оборачиваемому объекту из нескольких потоков?

3. Хотелось бы, чтобы при перемещении внутри выражения счётчик сохранялся, как будто обращения происходят к одному и тому же объекту:

   `(a->doSmth(), (b = std::move(a))->doSmth()); // 2`

   Подумайте, как это можно реализовать без динамического выделения памяти? Почему такое решение будет работать? Если захочется, реализуйте.

## Формальности

**Дедлайн:** 04:00 01.11.2020.

**Баллы:** 4 (+1) уе.

Класс `Spy` должен быть доступен в глобальном неймспейсе при подключении заголовочного файла `spy.hpp`. Этот заголовочный файл должен находиться в папке `task3`, расположенной в корне репозитория.

Код пушьте в ветку `task3` и делайте pull request в `master`.

Используйте всю мощь стандартной библиотеки, кроме `std::function`.

Отвечать на вопросы для размышлений необязательно.

## Тесты

Тесты этого задания можно собрать с address sanitizer'ом. Для этого нужно

* либо указать флаг `-DASAN=ON` в команде cmake,
  ```sh
  cmake -DREPOSITORY_PATH=/path/to/your/solutions -DTASK=3 -DASAN=ON ..
  ```

* либо установить переменную окружения `ASAN=ON` перед запуском cmake.
  ```sh
  ASAN=ON cmake -DREPOSITORY_PATH=/path/to/your/solutions -DTASK=3 ..
  ```
  Этот вариант также работает со [скриптами](https://github.com/Mrkol/mipt-metaprogramming-2021/tree/master/scripts).

Требуется cmake версии 3.13 или выше.


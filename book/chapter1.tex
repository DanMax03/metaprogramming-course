\chapter{Введение в шаблоны}
\section{Базовые понятия}
Шаблоном, согласно стандарту, называют отрывок кода специального вида\footnote{Вид этот определён сложной к прочтению формальной грамматикой.}, задающий семейство классов, функций или переменных, алиас\footnote{Алиасом называют имя, заданное посредством ключевого слова \inlcpp{using}.} на семейство типов, либо концепт. Прочитав это определение представить в голове что такое шаблон решительно невозможно, поэтому постараемся распутать его, пожертвовав в процессе точностью в угоду простоте, и выработать ментальную модель, пригодную для использования при написании кода.

Итак, не отступая далеко от <<официального>> определения, шаблоном мы действительно будем называть отрывок кода, состоящий из двух частей: заголовка и тела. Заголовок обязан выглядеть как \inlcpp{template<...>}, где на месте \inlcpp{...} перечисляются через запятую так называемые \textit{аргументы шаблона}, подробнее о которых будет ниже. Тело же обязано быть \textit{определением} или \textit{объявлением} некоторой сущности языка C++, например класса, структуры, функции или глобальной переменной. Незамедлительно перейдём к синтаксическим примерам, не обременяя себя семантикой происходящего:
\begin{minted}{c++}
// Шаблон структуры от двух аргументов-типов
template<class T, class U>
struct Pair
{
    T first;
    U second;
};

// Шаблон структуры от одного аргумента-не-типа
template<int Size>
struct ArrayOfBools
{
    bool values[Size];
};

// Шаблон алиаса
template<class U>
using SamePair = Pair<U, U>;

// Шаблон объявления функции
template<class T>
T square(T value);

// Шаблон определения функции
template<class T>
T square(T value)
{
    return value*value;
};
\end{minted}
Из примера видно, что в качестве аргумента шаблона может выступать как типы, так и значения (но некоторыми ограничениями). В первом случае используется синтаксис \inlcpp{class ArgumentName} или эквивалентный ему \inlcpp{typename ArgumentName}. Во втором случае синтаксис аналогичен обычным функциям.

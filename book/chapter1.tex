\chapter{Введение в шаблоны}
Основное применение шаблонов берёт свои корни в необходимости обобщать алгоритмы и структуры данных на произвольные типы, а как было замечено ещё в 70е годы, <<алгоритмы + структуры данных = программы>>, \cite{Wirth1976}.
Однако, как мы убедимся в рамках данного пособия, за годы их возможности и область применения вышли сильно за рамки этой изначальной мотивировки.
В рамках данной же главы мы познакомимся с этим базовым применением шаблонов.

\section{Шаблоны функций}
Суть этого понятия кроется в самом названии раздела.
Шаблон функции "--- отрывок кода, не являющийся сам по себе функцией, но служащий шаблоном, по которому компилятор будет создавать за нас новые функции.
Предположим, что мы реализовали алгоритм двоичного поиска целого числа в массиве:
\begin{minted}{c++}
size_t binarySearch(std::span<int const> data, int value)
{
  size_t left = 0;
  size_t right = data.size();
  while (right - left > 1)
  {
    size_t middle = std::midpoint(left, right);
    if (data[middle] <= value)
    {
      left = middle;
    }
    else
    {
      right = middle;
    }
  }
  return left;
}
\end{minted}
Ясно, что написанный нами код на самом деле не использует никаких уникальных для типа \inlcpp{int} свойств.
Алгоритм подходит и для \inlcpp{long long}, и для \inlcpp{float}.
Как добиться возможности использовать наш алгоритм и для других типов данных?

Плохой программист на языке C посоветует скопировать эту функцию несколько раз, заменяя \inlcpp{int} на другие интересующие нас типы данных, а в конец названия функции дописывая тип данных, с которым она работает.
Недостаток этого подхода очевиден: дублирование кода.
Когда коллега решит оптимизировать этот алгоритм посредством линейного поиска на массивах, влезающих в кэш-линию, он будет крайне недоволен необходимостью вписать эту оптимизацию в 5, а то и 10 мест.
Более опытный программист на C порекомендует воспользоваться макросами во избежание дублирования.
Такой подход используется, например, в функциях стандартной библиотеки C \inlcpp{fabs}, \inlcpp{fabsf} и \inlcpp{fabsl}.
Однако такой подход на самом деле не решает основную проблему: алгоритм не был обобщён, вместо этого было сделано три разных алгоритма с разными названиями.
Это не позволит использовать его в других обобщённых алгоритмах, не продолжая при этом дублировать код или использовать макросы.
Любой другой алгоритм использующий наш двоичный поиск тоже будет должен предоставлять несколько разных версий с суффиксами названия, соответствующими типу данных.
Более того, код для разных типов данных уже не может быть одинаковым, он обязан использовать разные версии функции бинарного поиска.
Конечно же и эта проблема решается ловким использованием макросов.
Но опасность злоупотребления макросами широко известна в среде системного программирования: макросы ничего не знают о синтаксисе языка, они лишь позволяют автоматизировать процесс копирования кода путём автоматических вставок.
Неосторожное их использование может быстро привести код в состояние спагетти.
Возможная реализация обобщения алгоритма \inlcpp{binarySearch} с использованием макросов приведена ниже.
\begin{minted}{c++}
#define MAKE_BINARY_SEARCH(Type, Suffix)        \
size_t binarySearch ## Suffix(                  \
  std::span<Type const> data, Type value)       \
{                                               \
  size_t left = 0;                              \
  size_t right = data.size();                   \
  while (right - left > 1)                      \
  {                                             \
    size_t middle = std::midpoint(left, right); \
    if (data[middle] <= value)                  \
    {                                           \
      left = middle;                            \
    }                                           \
    else                                        \
    {                                           \
      right = middle;                           \
    }                                           \
  }                                             \
  return left;                                  \
}
MAKE_BINARY_SEARCH(int, i)
MAKE_BINARY_SEARCH(float, f)
MAKE_BINARY_SEARCH(double, d)
\end{minted}
Стоит отметить, что язык C++, в отличии от C, позволяет перегружать функции.
Это решает проблему суффиксов, но не избавляет нас от необходимости использовать макросы.

Альтернативным подходом от мира C был бы отказ от использования конкретных типов, заменяя их на указатели на байты и используя указатель на функцию-компаратор:
\begin{minted}{c++}
size_t binarySearch(
  const void * dataStart, size_t elementSize,
  size_t elementCount, void * value,
  bool (* compare)(const void *, const void *))
{
  size_t left = 0;
  size_t right = elementCount;
  while (right - left > 1)
  {
    size_t middle = std::midpoint(left, right);
    const void * element =
      reinterpret_cast<const std::byte *>(dataStart)
      + middle * elementSize;
    if (compare(element, value))
    {
      left = middle;
    }
    else
    {
      right = middle;
    }
  }
  return left;
}
\end{minted}
Недостаток такого подхода очевиден: необходима низкоуровневая работа с байтами (аналогично стандартной функции \inlcpp{qsort}), засоряющая логику нашего алгоритма.
Есть у него и преимущество: пользователь может использовать алгоритм не только с предопределённым набором типов данных, но и со своими структурами и классами.
Но использование функции с таким интерфейсом нельзя назвать приятным, необходимо писать очень много служебного кода:
\begin{minted}{c++}
bool compareInt(const void * first, const void * second)
{
  return *reinterpret_cast<const int *>(first)
    <= *reinterpret_cast<const int *>(second);
}
...
std::vector<int> data = ...;
int target = 42;
binarySearch(data.data(), sizeof(data[0]), data.size(),
  &target, &compareInt);
\end{minted}
И наконец отметим, что мы пожертвовали производительностью в угоду общности.
Предыдущий подход позволял компилятору превратить оператор сравнения чисел в одну ассемблерную инструкцию, а в текущем в качестве компаратора может быть указатель на любую функцию, заинлайнить которую, вообще говоря, может не получится.

Похожий подход посовал бы программист на java.
А именно, выделить интерфейс с необходимым для работы алгоритма функционалом и вместо конкретного типа принимать указатели на интерфейсы, для примитивных типов написать обёртки аналогичные имеющимся в языке java (\mintinline{java}{Integer}, \mintinline{java}{Float} и т.д.), и хранить всё на куче.
\begin{minted}{c++}
struct IComparable
{
  virtual bool isLessOrEqual(IComparable const * other) = 0;
}

size_t binarySearch(
  std::span<IComparable const *> data,
  IComparable const * value)
{
  size_t left = 0;
  size_t right = data.size();
  while (right - left > 1)
  {
    size_t middle = std::midpoint(left, right);
    if (data[middle]->isLessOrEqual(value))
    {
      left = middle;
    }
    else
    {
      right = middle;
    }
  }
  return left;
}
\end{minted}
Этот подход достаточно похож на предыдущий, но больше нет нужды заниматься низкоуровневыми манипуляциями байтами.
Однако компромисс состоит в производительности: мы больше не можем передавать на вход алгоритму обычный массив данных, необходимо передавать массив указателей на данные.
Также вызов виртуального метода-компаратора ещё дороже, чем вызов указателя на функцию-компаратор.

Итак, перечислим недостатки, имеющиеся в рассмотренных подходах:
\begin{itemize}
\item сложный пользовательский интерфейс,
\item дублирование логики,
\item игнорирование синтаксиса языка (макросы),
\item протекание абстракций (необходимость работать с байтами),
\item необходимость в индерекции данных (интерфейсы),
\item необходимость в индерекции фукнций (компараторы).
\end{itemize}
К счастью, язык C++ предоставляет нам инструмент, позволяющий избежать каждой из этих проблем: шаблоны.
Как можно догадаться из объёма данного пособия, компромисс шаблонов состоит в сложности их использования.
Больше всего они похожи на первый из рассмотренных подходов.
Шаблон "--- аналог макроса, учитывающий синтаксис языка ещё до подстановки аргументов.
Язык поддерживает возможность написания шаблонов лишь для ограниченного числа сущностей в коде: функций, переменных, классов, псевдонимов и концептов.
\footnote{Являются ли концепты строго говоря шаблонами "--- спорный вопрос.}
Обобщение алгоритма \inlcpp{binarySearch} при помощи шаблонов выглядит следующим образом.
\begin{minted}[escapeinside=!!]{c++}
template<class T> !\mintlbl{ch1.templateHeader}!
size_t binarySearch(std::span<T const> data, T value)
{
  size_t left = 0;
  size_t right = data.size();
  while (right - left > 1)
  {
    size_t middle = std::midpoint(left, right);
    if (data[middle] <= value)
    {
      left = middle;
    }
    else
    {
      right = middle;
    }
  }
  return left;
}
\end{minted}
Формально, данный отрывок кода называется \textit{определением шаблона функции}.
Выражение \inlcpp{T} в этом коде называют \textit{аргументом шаблона}, строку \ref{ch1.templateHeader} \textit{заголовком шаблона}, а остальной код \textit{телом шаблона}.
Отметим, что вместо ключевого слова \inlcpp{class} в первой строчке возможно использование ключевого слова \inlcpp{typename}.
Эти ключевые абсолютно эквивалентны в контексте аргументов шаблона и не имеют отношения к классам как возможности языка C++.
Продолжая аналогию с макросами, мы можем явно попросить компилятор создать функцию по написанному нами шаблону:
\begin{minted}{c++}
template size_t binarySearch<int>(
  std::span<int const> data, int value);
\end{minted}
Понимать эту строчку следует как подстановку вместо неё тела шаблона с аргументами заменёнными на указанные в ней.
В данном случае все вхождения имени \inlcpp{T} заменятся на \inlcpp{int}.
Формально, процесс подстановки аргументов в шаблон и получение настоящей функции языка C++ называется \textit{инстанциацией}.
Результат процесса инстанциации, то есть получаемая в результате функция, называется \textit{специализацией}.
Само выражение, написанное выше, называют \textit{явной инстанциацией} (причина такого названия станет ясна ниже).
Имя функции, сгенерированной этой явной инстанциацией, выглядит как \inlcpp{binarySearch<int>}, а вызов соответственно как \inlcpp{binarySearch<int>(data, 42)}.

Однако явные инстанциации "--- не часто используемый на практике инструмент.
В отличии от макросов, компилятор способен самостоятельно отслеживать, с какими аргументами необходимо инстанцировать шаблон.
Можно считать, что в недрах компилятора для каждого шаблона функции хранится таблица соответствий набора аргументов определению получаемой в результате функции.
Таблица заполняется лениво по мере необходимости, то есть встретив в коде вызов функции \inlcpp{binarySearch<U>}, где \inlcpp{U} "--- какой-то конкретный тип, компилятор либо использует уже имеющееся определение функции из таблицы, либо предварительно сгенерирует новое и заполнит им ячейку в таблице.
\footnote{На самом деле этот механизм несколько сложнее в силу разделения общей компиляции программы на компиляцию объектных файлов и их линковку.}
Этот процесс формально называется \textit{неявной инстанциацией}, или просто \textit{инстанциацией}.

Обратим внимание на несколько важных деталей о взаимодействии шаблонов функций и структуры многофайловых проектов.
Определение шаблона функции не является определением функции, а значит на него не распростроняется one definition rule.
Следовательно, мы можем помещать определения шаблонов как и в заголовочных (\path{.hpp}) файлах, так и в компилируемых (\path{.cpp}) файлах.
Однако есть веская причина почти всегда помещать шаблоны в заголовочных файлах: для инстанциации шаблона необходимо иметь полное тело шаблона в текущем файле.
Из этого вытекает один из главных недостатков шаблонов.
Так как каждая единица трансляции компилируется из соответствующего \path{.cpp} файла независимо,\footnote{Это позволяет системам сборки запускать несколько процессов компиляции разных файлов параллельно на многоядерных системах.} у компилятора нет выбора кроме как заново инстанцировать шаблон в каждой единице трансляции, заново компилировать полученную инстанциацию в бинарный код и вкладывать его в каждый получаемый объектный файл.
На практике это приводит к <<раздуванию>> размера итогового бинарного файла программы и увеличению времени компиляции.
Как мы увидим в следующем разделе, первая из этих проблем уже не совсем актуальна.

Узнав про неявную инстанциацию у читателя мог возникнуть закономерный вопрос: а зачем вообще в языке C++ есть механизм явной инстанциации? Перед тем как ответить на этот вопрос, нам понадобится познакомиться с новым понятием, \textit{объявлением шаблона функции}:
\begin{minted}{c++}
template<class T>
size_t binarySearch(std::span<T const> data, T value);
\end{minted}
Если инстанциация определения шаблона функции с конкретными аргументами приводит к генерации определения функции, инстанциация объявления шаблона функции приводит к генерации объявления функции.
Это значит, попытавшись инстанциировать шаблон функции имея только объявление шаблона, но не определение шаблона, объектный файл скомпилируется, но программа в целом не слинкуется, если в каком-то другом объектном файле не было инстанцировано определение.
На практике возможность отдельно определять и объявлять шаблоны функций используется двумя способами.

Во-первых, традиционно каждая пара \path{.cpp} и \path{.hpp} файлов отвечает одному мини-модулю программы, и в заголовочном файле принято оставлять исключительно публичное API этого модуля.
Это позволяет читающему код легко использовать имеющийся код не влезая в детали имплементации, а также не компилировать заново все использующие заголовочный файл модули при изменении деталей имплементации.
Шаблоны функций же нарушают эту традицию, у программиста нет выбора, кроме как помещать имплементации (определения шаблонов) в заголовочный файл, иначе использующий этот мини-модуль код не сможет инстанцировать шаблон и получить определение функции.
С точки зрения механики компиляции, с этим поделать ничего нельзя, однако, с точки зрения синтаксиса и удобства чтения кода пользователем, ситуацию можно улучшить использовав объявления шаблонов следующим образом.
\begin{minted}{c++}
// Файл binarySearch.hpp
#pragma once

#include <span>
#include <cstddef>

template<class T>
size_t binarySearch(std::span<T const> data, T value);

#include "binarySearch.ipp"

// Файл binarySearch.ipp

template<class T>
size_t binarySearch(std::span<T const> data, T value)
{
  ...
}
\end{minted}
Заголовочный файл был разделён на 2 половины: файл \path{.hpp} (header) с объявлениями шаблонов и файл \path{.ipp} (implementation) с определениями шаблонов, где первый подключает второй в свой конец.
Таким образом, человеку, желающему использовать этот модуль и не интересующемуся внутренним его устройством, достаточно прочитать содержимое файла \path{.hpp}, а открывать и пролистывать содержимое файла \path{.ipp} нужды нет, аналогично обычному, не шаблонному коду.
В нашем примере преимущество не велико, однако для заголовочных файлов с десятками шаблонов эта техника незаменима.

Во-вторых, есть ситуации, когда шаблон предполагается использовать с очень ограниченным семейством типов, например, только с примитивными числовыми типами.
В этой ситуации возможно полное разделение объявления и определения. В заголовочном файле будет помещено лишь объявление шаблона, а определение будет скрыто от пользователя в \path{.cpp} файле, где также при помощи явных инстанциаций будут сгенерированы все необходимые специализации.
Нахождением же соответствий между специализациями объявления и специализациями определения будет линковщик.
\begin{minted}{c++}
// Файл binarySearch.hpp
#pragma once

#include <span>
#include <cstddef>

template<class T>
size_t binarySearch(std::span<T const> data, T value);

// Файл binarySearch.cpp

template<class T>
size_t binarySearch(std::span<T const> data, T value)
{
  ...
}

// Специализации binarySearch для int и float
// будут помещены в текущей единице трансляции
// и будут видны линковщику извне.
template size_t binarySearch<int>(
  std::span<int const> data, int value);
template size_t binarySearch<float>(
  std::span<float const> data, float value);
\end{minted}
В случае с двоичным поиском, вероятно, такое разделение излишне, ведь пользователь может захотеть использовать его с произвольными типами данных, но время от времени эта техника действительно используется на практике.
Именно ради неё в язык C++ и был добавлен механизм явных инстанциаций.

Рассмотрим ещё одну возможность шаблонов функций, \textit{явные специализации}.
\footnote{Вообще говоря официальное название "--- \textit{явная полная специализация}.}
Напомним, что специализацией называется функция результат инстанциации шаблона.
Предположим, что целевая платформа поддерживает специальную функцию \inlcpp{fastIntSearch}, способную очень быстро найти индекс целого числа в массиве размера меньше, скажем, 16 элементов.
Хотелось бы, чтобы функция \inlcpp{binarySearch} использовала эту инструкцию как только область поиска стала достаточно маленькой, но исключительно для типа данных \inlcpp{int}.
Как изменить код специализации \inlcpp{binarySearch<int>}, не поменяв при этом код всех остальных специализаций? Ровно это позволяет сделать следующий отрывок кода.
\begin{minted}{c++}
template<>
size_t binarySearch<int>(std::span<int const> data, int value)
{
  size_t left = 0;
  size_t right = data.size();
  while (right - left > 16)
  {
    size_t middle = std::midpoint(left, right);
    if (data[middle] <= value)
    {
      left = middle;
    }
    else
    {
      right = middle;
    }
  }
  return fastIntSearch(data.subspan(left, right - left), value);
}
\end{minted}
Если в области видимости на момент использования \inlcpp{binarySearch<int>} содержится и основное определение шаблона, и этот отрывок кода, называемый \textit{явной специализацией}, то использована будет именно эта, явно имплементированная отдельно от шаблона специализация.
Стоит обратить внимание, что на момент объявления явной специализации шаблон функции уже должен быть объявлен.
Также заметим, что явная специализация является обычным определением функции, а поэтому может быть разделено на объявление и определение, где первое следует помещать в заголовочный файл, а второе в \path{.cpp}-файл:
\begin{minted}{c++}
// binarySearch.hpp
...
template<>
size_t binarySearch<int>(std::span<int const> data, int value);

// binarySearch.cpp
...
template<>
size_t binarySearch<int>(std::span<int const> data, int value)
{
  ...
}
\end{minted}
Если поместить определение явной специализации в заголовочный файл, необходимо пометить её как \inlcpp{inline}, иначе мы нарушим ODR.
\footnote{One definition rule.}

В заключение раздела упомянем о \textit{выведении типов}.
До сих пор мы явно указывали шаблонные аргументы для специализаций в момент вызова или специализации.
Работая с более сложными шаблонами необходимость указывать эти аргументы быстро становится обременяющей, поэтому в C++ был добавлен достаточно сложный механизм автоматического выведения типа шаблонных аргументов.
Детали работы этого механизма будут рассмотрены в одной из следующих глав, а сейчас лишь скажем, что в большом количестве случаев указывать шаблонные аргументы не обязательно:
\begin{minted}{c++}
void foo()
{
  std::vector<int> data{...};
  int value = 42;
  // Тип T автоматически будет выведен как int
  // на основании типа аргумента value.
  binarySearch(data, value);
}

// Аналогично для явных специализаций
template<>
size_t binarySearch(std::span<int const> data, int value)
{
  ...
}
\end{minted}

\subsection*{Упражнения}
\begin{enumerate}
\item Задумайтесь, что произойдёт, если попытаться инстанцировать шаблон binarySearch с аргументом типа \inlcpp{Person}, описанным ниже.
Попробуйте написать это.
Что нужно сделать, чтобы функция искала человека по возрасту? Легко ли было это понять?
\begin{minted}{c++}
struct Person
{
  std::string name;
  uint32_t age;
};
\end{minted}
\item Напишите шаблон функции \inlcpp{pairLess} от одного аргумента с типом произвольной специализации \inlcpp{std::pair}, возвращающую \inlcpp{true} если первый элемент меньше второго, а иначе \inlcpp{false}.
Обратите внимание, типы первого и второго элемента пары могут отличаться.
О синтаксисе шаблона с несколькими аргументами читателю предлагается догадаться самостоятельно.
\item Что произойдёт, если забыть объявить явную специализацию в заголовочном файле?
\item Рассмотрим следующий код.
\begin{minted}{c++}
// Часть интерфейса библиотеки
struct GraphicsState
{
  bool enableWireframe;
  std::string noiseTextureName;
  std::optional<PipelineDescription> pipelineDescription;
  ...
};

// Часть имплементации библиотеки
struct InternalGraphicsState
{
  bool enableWireframe;
  TexturePtr noiseTexture;
  std::optional<PipelineDescription> pipelineDescription;
  ...
};

InternalGraphicsState convertState(
  const GraphicsState& state)
{
  InternalGraphicsState result;
  result.enableWireframe = state.enableWireframe;
  if (!noiseTextureName.empty())
  {
    result.noiseTexture =
      getTexture(state.noiseTextureName);
  }
  result.pipelineDescription = state.pipelineDescription;

  ...

  return result;
}

struct InternalGraphicsStateDelta
{
  // std::nullopt означает отсутствие изменения
  std::optional<bool>
    enableWireframe;
  std::optional<Texture>
    noiseTexture;
  std::optional<Pipeline>
    pipeline;
  ...
};

InternalGraphicsStateDelta calculateDelta(
  const InternalGraphicsState& before,
  const InternalGraphicsState& after)
{
  InternalGraphicsStateDelta result;
  if (before.enableWireframe
    != after.enableWireframe)
  {
    result.enableWireframe = after.enableWireframe;
  }

  if (before.noiseTexture
    != after.noiseTexture)
  {
    result.noiseTexture = after.noiseTexture;
  }

  if (before.pipelineDescription
    != after.pipelineDescription)
  {
    result.pipeline = createPipeline(
      after.pipelineDescription)
  }

  ...

  return result;
}
\end{minted}
% \unskip
Используя шаблоны функций и, возможно, макросы, избавьте код от копипасты логики и сделайте добавление новых полей-состояний в эти структуры более безболезненным.
Для поддержки <<особенных>> полей воспользуйтесь явной специализацией шаблонов функций.
\end{enumerate}

\section{Шаблоны методов}
Помимо <<свободных>> функций в языке C++ поддерживаются связанные с классом функции, называемые \textit{методами}.
Методы также можно генерировать при помощи шаблонов:
\begin{minted}{c++}
class Any
{
public:
  template<class T>
  T * castTo()
  {
    return reinterpret_cast<T *>(data_);
  }
private:
  void * data_;
};
\end{minted}
Определение шаблонов методов также можно отделять от объявления:
\begin{minted}{c++}
template<class T>
T * Any::castTo() {...}
\end{minted}
Со специализациями же есть одна тонка деталь, согласно стандарту их необходимо помещать вне объявления класса:
\begin{minted}{c++}
// Объявление явной специализации
template<>
int * Any::castTo<int>();
template<>
// Определение явной специализации
int * Any::castTo<int>() {...}
\end{minted}
Но компилятор MSVC позволяет помещать их и внутри самого класса.
Использовать эту возможность, разумеется, не стоит, так как это делает код платформозависимым.

\section{Шаблоны глобальных переменных}

Искушённый знанием языка C читатель знает, что в объектном файле скомпилированной программы бывает два вида символов: функции и переменные.
Если C++ позволяет генерировать символы функций из шаблонов, было бы странно запрещать генерировать символы переменных.
И действительно, язык поддерживает \textit{шаблоны переменных}, однако, за исключением упомянутого в следующем разделе частного случая, используются они сильно реже шаблонов функций.

Синтаксис шаблонов переменных абсолютно аналогичен синтаксису шаблонов функций, как и набор языковых средств, связанных с ним.
\begin{minted}{c++}
// Объявление шаблона переменной
template<class T>
extern std::vector<T> globalStorage;

// Определение шаблона переменной
template<class T>
std::vector<T> globalStorage;

// Явная инстанциация
template std::vector<int> globalStorage<int>;

// Явная специализация
template<>
NotStdVector<bool> globalStorage<bool>;
\end{minted}

Как можно понять из примера, в чистом виде шаблоны глобальных переменных в основном используются в качестве параметризированного глобального хранилища в процедурном коде.

Ранее уже упоминалось, что шаблоны повторно инстанцируются в разных объектных файлах, в результате чего символ специализации может содержаться в нескольких объектных файлах.
Для функций эта особенность не страшна, так как соответствующий специализации символ указывает на неизменяемый код функции.
Для переменных же возникает опасение: если одной переменной соответствует несколько символов с разным хранилищем, то на самом деле мы получим не одну переменную, а несколько независимо меняющихся переменных.
Но на самом деле опасение напрасно, в результате статической линковки и для функций и для переменных будет оставлен только один их экземпляр в итоговом бинарном файле.
На типичных платформах достигается это за счёт механизма \textit{слабых} символов.
При компиляции обычных функций и переменных в единице трансляции генерируются сильные символы.
Если при линковке сильный символ с одинаковым названием содержится в нескольких единицах трансляции, линковщик выдаст ошибку.
В случае же функций и переменных, являющихся специализациями шаблонов, либо помеченных как inline, компилятор генерирует слабые символы.
Встретив несколько слабых символов с одинаковым именем, линковщик выкинет все из них кроме одного.
Таким образом в итоговой программе будет содержаться лишь один экземпляр каждой функции и переменной.

Стоит отметить, что с точки зрения стандарта C++ никаких символов не существует.
Линковка шаблонов описана куда более абстрактным языком, и частенько оказывается оторванной от практики.
В крупных проектах итоговая программа не редко разбита на множество динамических библиотек.
Например, Unreal Engine разбит на множество \path{dll}-файлов для возможности горячей перезагрузки\footnote{Hot reload, возможность перекомпилировать часть проекта и подгрузить изменения в уже работающий процесс без его перезагрузки.} отдельных модулей без полной перезагрузки редактора, а в использующих GNU core utilities операционных системах б\'{о}льшая часть функционала вынесена в \path{so}-библиотеки для экономии памяти и удобства обновления отдельных модулей системы.
Отличие динамических библиотек от статических в том, что нахождение расположения символов происходит не в момент компиляции программы, а прямо в процессе работы, через обращение к линковщику операционной системы.
Таким образом, в момент компиляции символы из статических библиотек копируются в итоговый бинарный файл нашей программы, потенциально выкидывая дубликаты слабых символов, а символы из динамических библиотек лишь порождают <<заглушки>>, помогающие программе загружать необходимые символы по мере нужды.
К сожалению, при загрузке символов в рантайме не происходит дедупликации слабых символов, а поэтому одна и та же специализация шаблонной переменной из разных \path{so} или \path{dll} файлов будет на самом деле ссылаться на разную память, иначе говоря, это будут две разные, независимые переменные.
По этой причине стоит избегать шаблонов переменных при проектировании публичных интерфейсов библиотек.
\footnote{Более подробно о механизме динамической линковки можно почитать в \cite{DynamicLinking}.}


\section{constexpr, consteval, constinit}
Начиная с C++11 в языке по чуть-чуть начали появляться новые инструменты метапрограммирования, выступающие и альтернативой и дополнением к шаблонам: титулярные ключевые слова.
В общем и целом, все они предназначены для переноса выполнения некоторых вычислений из рантайма в компайлтайм.
Рассмотрим следующий пример.
\begin{minted}{c++}
enum class LogLevel
{
  Info, Warning, Error, Fatal
};

std::unordered_map<LogLevel, std::string> logLevelStrings
  {
    {Color::Info, "INFO"},
    {Color::Warning, "WARNING"},
    ...
  };

...

#define LOG_WARN(msg) \
std::printf("[%s] (%s:%d): %s",
  logLevelStrings.at(LogLevel::Warning),
  __FILE, __LINE__,
  msg);
\end{minted}
Подобный код для логирования можно встретить во многих промышленных проектах.
Чем плох наш вариант? Обратить внимание стоит на поиск элемента в \inlcpp{std::unordered_map}.
Он хоть и работает за $O(1)$, но всё равно не бесплатен.
Пользователю приходится платить за поиск известного во время компиляции элемента в хеш-таблице временем в рантайме.
Конечно же, можно полностью отказаться от использования таблицы и вписать нужную строку прямо в макрос, но это решение не расширяется на большее число различной инфраструктуры, связанной с логированием.
Достаточно скоро эта строка начнёт копироваться в различные места, что в приведёт к нарушению правила одного источника истины.
\footnote{SSOT, single source of truth \cite{ssotWiki}.}
Хранение строк в константах тоже не будет являться лучшим решением, так как может быть потеряна строгость типизации в различных функциях системы, а именно элементы перечисления будут заменены на \inlcpp{const char *}.
Вместо этого заменим таблицу на функцию:
\begin{minted}{c++}
enum class LogLevel
{
  Info, Warning, Error, Fatal
};

const char * logLevelToString(LogLevel level)
{
  switch (level)
  {
    case LogLevel::Info: return "INFO";
    ...
  }
  return "?";
}
\end{minted}
Прыжок в \inlcpp{switch} однозначно будет дешевле вычисления хеш-функции, однако работа по выполнению этого прыжка всё ещё лишняя: если аргумент \inlcpp{level} известен на момент компиляции, то теоретически должно быть известно и возвращаемое значение функции.
Именно эту проблему решает ключевое слово \inlcpp{consteval}.
Дописав его перед сигнатурой функции, компилятору будет \textbf{запрещено} компилировать эту функцию в традиционном смысле этого слова, и разрешено лишь вычислять её результат \textit{прямо во время компиляции}:
\begin{minted}{c++}
consteval const char * logLevelToString(LogLevel level) {...}

// ...

int main(int argc, char ** argv)
{
  int level = 0;
  std::cin >> level;
  // Ошибка компиляции: LogLevel{level}
  // не является константным выражением
  std::cout << logLevelToString(LogLevel{level});
  // OK! Всё выражение после `<<` будет
  // вычислено в момент компиляции, в
  // итоговом бинарном файле будет лишь вызов
  // `operator<<(std::cout, "FATAL")`.
  std::cout << logLevelToString(LogLevel::Fatal);
}
\end{minted}
В случае же если запрещать вычисление функции в рантайме нет необходимости, но желательно желательно иметь возможность вычислять результат вызова функции во время компиляции когда это возможно или необходимо, следует использовать ключевое слово \inlcpp{constexpr} вместо \inlcpp{consteval}.
Подчеркнём это дважды: для функций \inlcpp{consteval} означает <<всегда в компайлтайме>>, а \inlcpp{constexpr} означает <<можно в компайлтайме>>.
Также заметим, что ключевые слова \inlcpp{constexpr} и \inlcpp{consteval} автоматически помечают функции как \inlcpp{inline}, поэтому тела таких функций можно и нужно помещать в заголовочные файлы, ведь иначе компилятор не сможет вычислить функцию в момент компиляции.
\footnote{При вычислении функций во время компиляции код на C++ на самом деле интерпретируется, и происходит это именно во время компиляции единицы трансляции, а не во время линковки.}

Обратим внимание на понятие \textit{константного выражения}, упомянутое в примере выше.
Для наших целей достаточно интуитивного его понимания как \textit{выражения, которое можно вычислить в момент компиляции}, более точное определение содержится в стандарте.
Примерами константных выражений являются все литералы и вызовы \inlcpp{constexpr} и \inlcpp{consteval} функций от них.
Контрпримером же является переменная \inlcpp{int level} в примере выше, так как в неё можно поместить данные, известные только в рантайме.
Однако константные переменные могут как быть так и не быть константными выражениями в зависимости от константности выражения, которым они инициализированы.

Ключевое слово \inlcpp{constexpr} можно также использовать с переменными.
К типу таких переменных неявно добавляется ключевое слово \inlcpp{const}, а выражение, которым инициализируется такая переменная, может быть только константным.
Таким образом, значение \inlcpp{constexpr}-переменной всегда известно во время компиляции, то есть является константным выражением, и не может быть изменено в рантайме.
Более того, компилятор по возможности будет избегать включения такой переменной как символа в скомпилированную программу.
\begin{minted}{c++}
constexpr size_t DATA_AMOUNT = 42;
...
// DATA_AMOUNT скорее всего не породит символа
std::array<int, DATA_AMOUNT> data;

...

// Обратите внимание, тип MESSAGE --
// const char * const, то есть константный
// указатель на константный char.
constexpr const char * MESSAGE = "Fatal error!";
...
// MESSAGE породит символ в разделе rodata,
// в котором будет сохранена соответствующая строка
std::cout << MESSAGE;
\end{minted}
Перекладывая этот инструмент на наш изначальный пример, мы можем изменить код процедуры \inlcpp{logLevelToString} сделав его data-driven вместо code-driven:
\begin{minted}{c++}
struct LogLevelInfo
{
  LogLevel level;
  const char * name;
};

constexpr std::array logLevelInfos
  {
    LogLevelInfo{LogLevel::Info, "INFO"},
    ...
  };

constexpr const char * logLevelToString(LogLevel level)
{
  for (auto[l, name] : logLevelInfos)
  {
    if (l == level)
    {
      return name;
    }
  }
  return "UNKNOWN";
}
\end{minted}
Отметим, что использовать \inlcpp{std::unordered_map} вместо массива структур не получится, так как стандарт пока что не требует от методов контейнера \inlcpp{std::unordered_map} наличия пометки \inlcpp{constexpr}, хотя теоретически написать хеш-таблицу, которую можно использовать в константных выражениях, возможно.

Наконец, освятим последнее титулярное ключевое слово, \inlcpp{constinit}.
Оно является <<урезанной>> версией слова \inlcpp{constexpr} и применимо только в отношении глобальных переменных,\footnote{Если быть точнее, переменных со статическим или тред-локальным временем жизни.} и требует, чтобы инициализатор переменной был константным выражением, не добавляя при этом константности к типу, а также не делая саму переменную константным выражением.
\todo{пример использования}

В прошлом разделе мы отмечали, что шаблоны переменных используются реже шаблонов функций, за исключением одного частного случая.
Этот частный случай "--- шаблоны constexpr-переменных.
Основная их ценность состоит в возможности моделировать различные отображения типов в значения.
Например, мы можем задать отображение, возвращающее \inlcpp{true} для типов с плавающей точкой и \inlcpp{false} иначе:
\begin{minted}{c++}
template<class T>
constexpr bool isFloatingPoint = false;

template<>
constexpr bool isFloatingPoint<float> = true;

template<>
constexpr bool isFloatingPoint<double> = true;

template<>
constexpr bool isFloatingPoint<long double> = true;
\end{minted}
Однако используя только лишь шаблоны constexpr-переменных не удастся выразить большинство полезных отображений, для этого потребуется инструменты из следующих разделов.

Пока что же осветим ещё один инструмент языка C++ использующий ключевое слово \inlcpp{constexpr}.
\begin{minted}{c++}
template<class T>
T dotProduct(std::span<const T> first,
  std::span<const T> second)
{
  T result = T{0};
  assert(first.size() == second.size());
  for (size_t i = 0; i < first.size(); ++i)
    result += first[i] * second[i];
  return result;
}
\end{minted}
Пример выше содержит наивную имплементацию скалярного произведения для двух векторов со скаляром произвольного типа T.
Если для пользовательских сложных типов \inlcpp{T} такая имплементация и может быть оптимальной, для типов с плавающей точкой большинство платформ предоставляет набор специальных векторизированных операций, в том числе и скалярное произведение для векторов ограниченного размера.
Неплохо было бы оптимизировать эту функцию для случаев чисел с плавающей точкой.
Если целевая платформа поддерживает векторизацию только для \inlcpp{float}, можно воспользоваться уже изученной явной специализацией шаблонов функций, но что если платформа предоставляет набор перегруженных векторизированных функций для всех трёх видов чисел с плавающей точкой? Хотелось бы просто разобрать два случая:
\begin{minted}{c++}
template<class T>
T dotProduct(std::span<const T> first,
  std::span<const T> second)
{
  T result = T{0};
  assert(first.size() == second.size());
  if (isFloatingPoint<T>)
  {
    // Имплементация с использованием векторизации
    // (баг допущен намерено)
    for (size_t i = 0; i < first.size(); i += 4)
      result += builtinScalarProduct4(
        first.data() + i, second.data() + i);
  }
  else
  {
    ... // Старая имплементация
  }
  return result;
}
\end{minted}
Но такой код не скомпилируется, если перегрузки \inlcpp{builtinScalarProduct4} не существует для \inlcpp{T}, то есть функция будет работать только для встроенных типов с плавающей точкой.
Решить эту проблему поможет конструкция \inlcpp{if constexpr}:
\begin{minted}{c++}
template<class T>
T dotProduct(std::span<const T> first,
  std::span<const T> second)
{
  T result = T{0};
  assert(first.size() == second.size());
  if constexpr (isFloatingPoint<T>)
  {
    ...
  }
  else
  {
    ...
  }
  return result;
}
\end{minted}
Эта вариация обычного \inlcpp{if} заставляет компилятор вычислять условие в скобках в момент компиляции, и полностью выкидывать из рассмотрения ненужную ветку, что позволяет писать в неактивной ветке семантически некорректный код, а именно вызов несуществующей перегрузки \inlcpp{builtinScalarProduct4}.
Очень важно понимать, что условие \textit{всегда} будет вычисляться в момент компиляции и всегда должно быть константным выражением.
С 20й версии стандарта языка в стандартной библиотеке появилась функция \inlcpp{std::is_constant_evaluated}.
Она возвращает \inlcpp{true} если была вычислена в момент компиляции и \inlcpp{false} если в рантайме:
\begin{minted}{c++}
// alwaysTrue всегда будет true, так как
// компилятор всегда старается инициализировать
// глобальные переменные в момент компиляции
bool alwaysTrue = std::is_constant_evaluated();

void foo()
{
  // alwaysFalse всегда false
  bool alwaysFalse = std::is_constant_evaluated();
  std::cout << alwaysFalse;
}
\end{minted}
Добавлена эта функция в язык была с целью упростить реализацию \inlcpp{constexpr} версий различных функций.
Как пример, вернёмся к функции \inlcpp{dotProduct}.
Платформозависимые функции вроде \inlcpp{builtinScalarProduct4} обычно не помечены как \inlcpp{constexpr}, так как реализованы ассемблерными вставками.
Это означает, что даже если пометить шаблон функции \inlcpp{dotProduct} как \inlcpp{constexpr}, вычислить его специализацию для \inlcpp{float} компилятору не удастся.
С первого взгляда может показаться, что достаточно добавить в условие выбора реализации функции \inlcpp{std::is_constant_evaluated}, чтобы при вычислении \inlcpp{dotProduct} в компайлтайме всегда использовалась вторая реализация:
\begin{minted}{c++}
template<class T>
constexpr T dotProduct(std::span<const T> first,
  std::span<const T> second)
{
  T result = T{0};
  assert(first.size() == second.size());
  // Неправильно!
  if constexpr (isFloatingPoint<T>
    && !std::is_constant_evaluated())
  {
    ...
  }
  else
  {
    ...
  }
  return result;
}
\end{minted}
Но, как уже было подчёркнуто, условие в конструкции \inlcpp{if constexpr} \textit{всегда} вычисляется в момент компиляции, а поэтому добавление \inlcpp{&& !std::is_constant_evaluated())} полностью выключило первую ветку условия, ведь выражение \inlcpp{std::is_constant_evaluated()} всегда будет равно \inlcpp{true} в этом контексте.
Правильным решением проблемы будет использование обычной конструкции \inlcpp{if}:
\begin{minted}{c++}
template<class T>
constexpr T dotProduct(std::span<const T> first,
  std::span<const T> second)
{
  T result = T{0};
  assert(first.size() == second.size());
  if (!std::is_constant_evaluated()
  {
    if constexpr (isFloatingPoint<T>)
    {
      // Имплементация через builtinScalarProduct4
      ...
    }
    else
    {
      // Наивная имплементация
      ...
    }
  }
  else
  {
    // Наивная имплементация
    ...
  }
  return result;
}
\end{minted}
Однако использование \inlcpp{std::is_constant_evaluated} с обычным \inlcpp{if} все ещё не удовлетворительно для некоторых ситуаций.
Рассмотрим следующий пример:
\begin{minted}{c++}
consteval int fooImpl1(int) { ... }

int fooImpl2(int) { ... }

constexpr int foo(int i)
{
  if (std::is_constant_evaluated())
  {
    // Ошибка компиляции!
    return fooImpl1(i);
  }
  else
  {
    return fooImpl2(i);
  }
}
\end{minted}
В данном отрывке кода вызов функции \inlcpp{fooImpl1} вызовет ошибку компиляции в силу того, что это выражение не возможно вычислить на этапе компиляции, так как не известно значение \inlcpp{i}, а \inlcpp{consteval} функции запрещено вычислять в рантайме.
Естественной реакцией на такую ошибку было бы дописать \inlcpp{constexpr} после \inlcpp{if}, но такой подход ошибочен, как только что было продемонстрировано.
Для решения этой проблемы в 23й версии языка была добавлена новая конструкция, \inlcpp{if consteval}:
\begin{minted}{c++}
constexpr int foo(int i)
{
  if consteval
  {
    return fooImpl1(i);
  }
  else
  {
    return fooImpl2(i);
  }
}
\end{minted}
Её семантика аналогична \inlcpp{if (std::is_constant_evaluated())}, но при этом ненужная ветка выкидывается компилятором из рассмотрения, как и в случае с \inlcpp{if constexpr}, что предотвращает ошибку компиляции.

В заключение раздела поговорим об ограничениях constexpr функций и переменных.
На момент добавления этих возможностей в язык, ограничений было очень много: нельзя было выделять память на куче, использовать циклы и условия, и многое другое.
Но с каждой следующей версией стандарта ограничений становится всё меньше, поэтому при написании constexpr-функций не стоит намеренно ограничивать себя в использовании языковых инструментов, а для сложных случаев всегда можно посмотреть точные требования в \href{https://en.cppreference.com/w/cpp/language/constexpr#:~:text=A%20constexpr%20function%20must%20satisfy%20the%20following%20requirements%3A}{справочнике}.
Есть лишь одно исключение, достойное явного упоминания: в константных выражениях запрещено иметь undefined behavior.
Более того, компилятор обязан следить за этим фактом и выдавать ошибку компиляции если в процессе вычисления константного выражения возникла ситуация обозначенная стандартом как undefined behavior.
Например, если в ходе вычисления произошло переполнение знакового целого типа, компилятор обязан об этом сообщить, а программа считается некорректной.


\subsection*{Упражнения}
\begin{enumerate}
\item Придумайте как добиться семантики \inlcpp{if consteval} используя инструменты C++20.
\item Возьмите произвольный модуль написанного вами кода и попробуйте заставить его функционировать в компайлтайме используя материал данного раздела.
Не забывайте заглядывать на cppreference встречая ограничения \inlcpp{constexpr} функций.
\end{enumerate}

\section{Констрейнты и концепты}


\section{Шаблоны типов}

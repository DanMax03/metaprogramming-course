\chapter{Введение в шаблоны}
Основное применение шаблонов берёт свои корни в необходимости обобщать алгоритмы и структуры данных на произвольные типы. Однако, как мы убедимся в рамках данного пособия, за годы их возможнжости и область применения вышли сильно за рамки этой изначальной мотивировки. В рамках данной главы мы познакомимся с этим базовым применением шаблонов.
\section{Шаблоны функций}
Суть этого понятия кроется в самом названии раздела. Шаблон функции -- отрывок кода, не являющийся сам по себе функцией, но служащий шаблоном по которому компилятор будет создавать за нас функции. Предположим, что мы реализовали алгоритм двоичного поиска целого числа в массиве:
\begin{minted}{c++}
size_t binarySearch(std::span<int const> data, int value)
{
    size_t left = 0;
    size_t right = data.size();
    while (right - left > 1)
    {
        size_t middle = std::midpoint(left, right);
        if (data[middle] <= value)
        {
            left = middle;
        }
        else
        {
            right = middle;
        }
    }
    return left;
}
\end{minted}
Ясно, что написанный нами код на самом деле не использует никаких уникальных для типа \inlcpp{int} свойств. Алгоритм подходит и для \inlcpp{long long}, и для \inlcpp{float}. Как добиться возможности использовать наш алгоритм и для других типов данных?

Плохой программист на языке C посоветует скопировать эту функцию несколько раз, заменяя \inlcpp{int} на другие интересующие нас типы данных, а в конец названия функции дописывая тип данных, с которым она работает. Недостаток этого подхода очевиден: дублирование кода. Более опытный программист на C порекомендует воспользоваться макросами во избежание дублирования. Такой подход используется, например, в функциях стандартной библиотеки C \inlcpp{fabs}, \inlcpp{fabsf} и \inlcpp{fabsl}. Однако мы на самом деле не решили основную проблему: мы не обобщили алгоритм, а сделали три разных алгоритма с разными названиями. Это не позволит нам использовать его в других обобщённых алгоритмах не продолжая дублировать код или использовать макросы. Любой другой алгоритм использующий наш двоичный поиск тоже будет должен предоставлять несколько разных версий с суффиксами названия, соттветствующими типу данных. Более того, код для разных типов данных уже не может быть одинаковым, он обязан использовать разные версии функции бинарного поиска. Конечно же и эта проблема решается ловким использованием макросов. Но опасность излишнего использования макросов широко известна в среде системного программирования: макросы ничего не знают о синтаксисе языка, они лишь позволяют автоматизировать процесс копирования кода путём автоматических вставок. Неосторожное их использование может быстро привести код в состояние спагетти.
\begin{minted}{c++}
#define MAKE_BINARY_SEARCH(Type, Suffix)            \
size_t binarySearch ## Suffix(                      \
    std::span<Type const> data, Type value)         \
{                                                   \
    size_t left = 0;                                \
    size_t right = data.size();                     \
    while (right - left > 1)                        \
    {                                               \
        size_t middle = std::midpoint(left, right); \
        if (data[middle] <= value)                  \
        {                                           \
            left = middle;                          \
        }                                           \
        else                                        \
        {                                           \
            right = middle;                         \
        }                                           \
    }                                               \
    return left;                                    \
}
MAKE_BINARY_SEARCH(int, i)
MAKE_BINARY_SEARCH(float, f)
MAKE_BINARY_SEARCH(double, d)
\end{minted}
Стоит отметить, что язык C++, в отличии от C, позволяет перегружать функции. Это решает проблему суффиксов, но не избавляет нас от необходимости использовать макросы.

Альтернативным подходом от мира C было бы использование указателя на функцию-компаратор:
\begin{minted}{c++}
size_t binarySearch(
    const void* dataStart, size_t elementSize,
    size_t elementCount, void* value,
    bool (*compare)(const void*, const void*))
{
    size_t left = 0;
    size_t right = elementCount;
    while (right - left > 1)
    {
        size_t middle = std::midpoint(left, right);
        const void* element =
            reinterpret_cast<const std::byte*>(dataStart)
            + middle * elementSize;
        if (compare(element, value))
        {
            left = middle;
        }
        else
        {
            right = middle;
        }
    }
    return left;
}
\end{minted}
Недостаток такого подхода очевиден: необходима низкоуровневая работа с байтами (аналогично стандартной функции \inlcpp{qsort}), засоряющая логику нашего алгоритма. Есть у него и преимущество: пользователь может использовать алгоритм не только с предопределённым набором типов данных, но и со своими структурами и классами. И наконец мы избавили себя от необходимости писать несколько версий одной и той же функции. Однако использование функции с таким интерфейсом нельзя назвать приятным, необходимо писать очень много служебного кода:
\begin{minted}{c++}
bool compareInt(const void* first, const void* second)
{
    return *reinterpret_cast<const int*>(first)
        <= *reinterpret_cast<const int*>(second);
}
...
std::vector<int> data = ...;
int target = 42;
binarySearch(data.data(), sizeof(int), data.size(),
    &target, &compareInt);
\end{minted}
И наконец отметим, что мы пожертвовали производительностью в угоду общности. Предыдущий подход позволял компилятору превратить оператор сравнения чисел в одну ассемблерную инструкцию, а в текущем в качестве компаратора может быть указатель на любую фукнцию, заинлайнить которую вообще говоря может не получится.

Похожий подход посовал бы программист на java. А именно, выделить интерфейс с необходимым для работы алгоритма функционалом и вместо конкретного типа принимать указатели на интерфейсы, для примитивных типов написать обёртки аналогичные имеющимся в языке java (\mintinline{java}{Integer}, \mintinline{java}{Float} и т.д.), и хранить всё на куче.
\begin{minted}{c++}
struct IComparable
{
    virtual bool isLessOrEqual(IComparable const * other) = 0;
}

size_t binarySearch(
    std::span<IComparable const *> data,
    IComparable const * value)
{
    size_t left = 0;
    size_t right = data.size();
    while (right - left > 1)
    {
        size_t middle = std::midpoint(left, right);
        if (data[middle]->isLessOrEqual(value))
        {
            left = middle;
        }
        else
        {
            right = middle;
        }
    }
    return left;
}
\end{minted}
Этот подход достаточно похож на предыдущий, но нам больше не нужно заниматься низкоуровневыми манипуляциями байтами. Однако трейдоф состоит в производительности: мы больше не можем передавать на вход алгоритму обычный массив данных, необходимо передавать массив указателей на данные. Также вызов метода-компаратора ещё дороже чем вызов указателя на функцию-компаратор.

Итак, перечислим недостатки встречавшиеся нам в предыдущих подходах.
\begin{itemize}
\item Сложный пользовательский интерфейс
\item Дублирование логики
\item Игнорирование синтаксиса языка (макросы)
\item Протекание абстракций (необходимость работать с байтами)
\item Необходимость в индерекции данных (интерфейсы)
\item Необходимость в индерекции фукнций (компараторы)
\end{itemize}
К счастью, язык C++ предоставляет нам инструмент, позволяющий избежать каждой из этих проблем: шаблоны. Больше всего они похожи на первый рассмотренный нами подход с макросами. Шаблон -- аналог макроса, учитывающий синтаксис языка ещё до подстановки аргументов. Синтаксис шаблона функции выглядит следующим образом.
\begin{minted}{c++}
template<class T>
size_t binarySearch(std::span<T const> data, T value)
{
    size_t left = 0;
    size_t right = data.size();
    while (right - left > 1)
    {
        size_t middle = std::midpoint(left, right);
        if (data[middle] <= value)
        {
            left = middle;
        }
        else
        {
            right = middle;
        }
    }
    return left;
}
\end{minted}
Формально данный отрывок кода называется \textit{определением шаблона функции}. Выражение \inlcpp{T} в этом коде называют \textit{аргументом шаблона}, первую строчку \textit{заголовком шаблона}, а остальной код \textit{телом шаблона}. Отметим, что вместо ключевого слова \inlcpp{class} в первой строчке возможно использование ключевого слова \inlcpp{typename}. Эти ключевые абсолютно эквивалентны в контексте аргументов шаблона и не имеют отношения к классам как к фиче языка C++. Продолжая аналогию с макросами, мы можем явно попросить компилятор создать функцию по написанному нами шаблону:
\begin{minted}{c++}
template size_t binarySearch<int>(
    std::span<int const> data, int value);
\end{minted}
Понимать эту строчку следует как подстановку вместо неё тела шаблона с аргументами заменёнными на указанные в ней. В данном случае все вхождения имени \inlcpp{T} заменяется на \inlcpp{int}. Формально процесс подстановки аргументов в шаблон и получение настоящей функции языка C++ называется \textit{инстанциацией}. Результат процесса инстанциации, то есть получаемая в результате функция, тоже называется инстанциацией. Само выражение написанное выше называют \textit{явной инстанциацией} (причина такого названия станет ясна ниже). Имя функции, сгенерированной этой явной инстанциацией, выглядит как \inlcpp{binarySearch<int>}, а вызов соответственно как \inlcpp{binarySearch<int>(data, 42)}.

Однако, явные инстанциации -- весьма редко используемый на практике инструмент. В отличии от макросов, компилятор способен сам отслеживать с какими аргументами необходимо инстанцировать шаблон. Можно считать, что в недрах компилятора для каждого шаблона функции хранится таблица соответствий набора аргументов определению получаемой в результате функции. Таблица заполняется лениво по мере необходимости, то есть встретив в коде вызов функции \inlcpp{binarySearch<U>}, где \inlcpp{U} -- какой-то конкретный тип, компилятор либо использует уже имеющееся определение функции из таблицы, либо предварительно сгенерирует новое и заполнит им ячейку в таблице. Этот процесс формально называется \textit{неявной инстанциацией}, или просто \textit{инстанциацией}.

Обратим внимание несколько важных деталей о взаимодействии шаблонов функций и структуры многофайловых проектов. Определение шаблона функции не является определением функции, а значит на него не распростроняется one definition rule. Следовательно мы можем помещать определения шаблонов как и в заголовочных (.hpp) файлах, так и в компилируемых (.cpp) файлах. Однако есть веская причина почти всегда помещать шаблоны в заголовочных файлах: для инстанциации шаблона необходимо иметь полное тело шаблона в текущем файле. Из этого вытекает один из главных недостатков шаблонов. Так как каждая единица трансляции компилируется из соответствующего .cpp файла независимо\footnote{Это позволяет системам сборки запускать несколько процессов компиляции разных файлов параллельно на многоядерных системах}, у компилятора нет выбора кроме как заново инстанцировать шаблон в каждой единице трансляции, заново компилировать полученную инстанциацию в бинарный код и вкладывать его в каждый получаемый объектный файл. На практике это приводит к <<раздуванию>> размера итогового бинарного файла программы и увеличению времени компиляции. Как мы увидим дальше, первая из этих проблем уже не актуальна.

Узнав про неявную инстанциацию у читателя мог возникнуть закономерный вопрос: а зачем вообще в языке C++ есть механизм явной инстанциации? Перед тем как ответить на этот вопрос, нам понадобится познакомиться с новым понятием, \textit{объявлением шаблона функции}:
\begin{minted}{c++}
template<class T>
size_t binarySearch(std::span<T const> data, T value);
\end{minted}

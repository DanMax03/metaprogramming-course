\chapter{Введение в шаблоны}
Основное применение шаблонов берёт свои корни в необходимости обобщать алгоритмы и структуры данных на произвольные типы. Однако, как мы убедимся в рамках данного пособия, за годы их возможнжости и область применения вышли сильно за рамки этой изначальной мотивировки. В рамках данной главы мы познакомимся с этим базовым применением шаблонов.
\section{Шаблоны функций}
Суть этого понятия кроется в самом названии раздела. Шаблон функции -- отрывок кода, не являющийся сам по себе функцией, но служащий шаблоном по которому компилятор будет создавать за нас функции. Предположим, что мы реализовали алгоритм двоичного поиска целого числа в массиве:
\begin{minted}{c++}
size_t binarySearch(std::span<int const> data, int value)
{
    size_t left = 0;
    size_t right = data.size();
    while (right - left > 1)
    {
        size_t middle = std::midpoint(left, right);
        if (data[middle] <= value)
        {
            left = middle;
        }
        else
        {
            right = middle;
        }
    }
    return left;
}
\end{minted}
Ясно, что написанный нами код на самом деле не использует никаких уникальных для типа \inlcpp{int} свойств. Алгоритм подходит и для \inlcpp{long long}, и для \inlcpp{float}. Как добиться возможности использовать наш алгоритм и для других типов данных?

Плохой программист на языке C посоветует скопировать эту функцию несколько раз, заменяя \inlcpp{int} на другие интересующие нас типы данных, а в конец названия функции дописывая тип данных, с которым она работает. Недостаток этого подхода очевиден: дублирование кода. Более опытный программист на C порекомендует воспользоваться макросами во избежание дублирования. Такой подход используется, например, в функциях стандартной библиотеки C \inlcpp{fabs}, \inlcpp{fabsf} и \inlcpp{fabsl}. Однако мы на самом деле не решили основную проблему: мы не обобщили алгоритм, а сделали три разных алгоритма с разными названиями. Это не позволит нам использовать его в других обобщённых алгоритмах не продолжая дублировать код или использовать макросы. Любой другой алгоритм использующий наш двоичный поиск тоже будет должен предоставлять несколько разных версий с суффиксами названия, соттветствующими типу данных. Более того, код для разных типов данных уже не может быть одинаковым, он обязан использовать разные версии функции бинарного поиска. Конечно же и эта проблема решается ловким использованием макросов. Но опасность излишнего использования макросов широко известна в среде системного программирования: макросы ничего не знают о синтаксисе языка, они лишь позволяют автоматизировать процесс копирования кода путём автоматических вставок. Неосторожное их использование может быстро привести код в состояние спагетти.
\begin{minted}{c++}
#define MAKE_BINARY_SEARCH(Type, Suffix)            \
size_t binarySearch ## Suffix(                      \
    std::span<Type const> data, Type value)         \
{                                                   \
    size_t left = 0;                                \
    size_t right = data.size();                     \
    while (right - left > 1)                        \
    {                                               \
        size_t middle = std::midpoint(left, right); \
        if (data[middle] <= value)                  \
        {                                           \
            left = middle;                          \
        }                                           \
        else                                        \
        {                                           \
            right = middle;                         \
        }                                           \
    }                                               \
    return left;                                    \
}
MAKE_BINARY_SEARCH(int, i)
MAKE_BINARY_SEARCH(float, f)
MAKE_BINARY_SEARCH(double, d)
\end{minted}
Стоит отметить, что язык C++, в отличии от C, позволяет перегружать функции. Это решает проблему суффиксов, но не избавляет нас от необходимости использовать макросы.

Альтернативным подходом от мира C было бы использование указателя на функцию-компаратор:
\begin{minted}{c++}
size_t binarySearch(
    const void* dataStart, size_t elementSize,
    size_t elementCount, void* value,
    bool (*compare)(const void*, const void*))
{
    size_t left = 0;
    size_t right = elementCount;
    while (right - left > 1)
    {
        size_t middle = std::midpoint(left, right);
        const void* element =
            reinterpret_cast<const std::byte*>(dataStart)
            + middle * elementSize;
        if (compare(element, value))
        {
            left = middle;
        }
        else
        {
            right = middle;
        }
    }
    return left;
}
\end{minted}
Недостаток такого подхода очевиден: необходима низкоуровневая работа с байтами (аналогично стандартной функции \inlcpp{qsort}), засоряющая логику нашего алгоритма. Есть у него и преимущество: пользователь может использовать алгоритм не только с предопределённым набором типов данных, но и со своими структурами и классами. И наконец мы избавили себя от необходимости писать несколько версий одной и той же функции. Однако использование функции с таким интерфейсом нельзя назвать приятным, необходимо писать очень много служебного кода:
\begin{minted}{c++}
bool compareInt(const void* first, const void* second)
{
    return *reinterpret_cast<const int*>(first)
        <= *reinterpret_cast<const int*>(second);
}
...
std::vector<int> data = ...;
int target = 42;
binarySearch(data.data(), sizeof(int), data.size(),
    &target, &compareInt);
\end{minted}
И наконец отметим, что мы пожертвовали производительностью в угоду общности. Предыдущий подход позволял компилятору превратить оператор сравнения чисел в одну ассемблерную инструкцию, а в текущем в качестве компаратора может быть указатель на любую фукнцию, заинлайнить которую вообще говоря может не получится.

Похожий подход посовал бы программист на java. А именно, выделить интерфейс с необходимым для работы алгоритма функционалом и вместо конкретного типа принимать указатели на интерфейсы, для примитивных типов написать обёртки аналогичные имеющимся в языке java (\mintinline{java}{Integer}, \mintinline{java}{Float} и т.д.), и хранить всё на куче.
\begin{minted}{c++}
struct IComparable
{
    virtual bool isLessOrEqual(IComparable const * other) = 0;
}

size_t binarySearch(
    std::span<IComparable const *> data,
    IComparable const * value)
{
    size_t left = 0;
    size_t right = data.size();
    while (right - left > 1)
    {
        size_t middle = std::midpoint(left, right);
        if (data[middle]->isLessOrEqual(value))
        {
            left = middle;
        }
        else
        {
            right = middle;
        }
    }
    return left;
}
\end{minted}
Этот подход достаточно похож на предыдущий, но нам больше не нужно заниматься низкоуровневыми манипуляциями байтами. Однако трейдоф состоит в производительности: мы больше не можем передавать на вход алгоритму обычный массив данных, необходимо передавать массив указателей на данные. Также вызов метода-компаратора ещё дороже чем вызов указателя на функцию-компаратор.

Итак, перечислим недостатки встречавшиеся нам в предыдущих подходах.
\begin{itemize}
\item Сложный пользовательский интерфейс
\item Дублирование логики
\item Игнорирование синтаксиса языка (макросы)
\item Протекание абстракций (необходимость работать с байтами)
\item Необходимость в индерекции данных (интерфейсы)
\item Необходимость в индерекции фукнций (компараторы)
\end{itemize}
К счастью, язык C++ предоставляет нам инструмент, позволяющий избежать каждой из этих проблем: шаблоны. Больше всего они похожи на первый рассмотренный нами подход с макросами. Шаблон -- аналог макроса, учитывающий синтаксис языка ещё до подстановки аргументов. Синтаксис шаблона функции выглядит следующим образом.
\begin{minted}{c++}
template<class T>
size_t binarySearch(std::span<T const> data, T value)
{
    size_t left = 0;
    size_t right = data.size();
    while (right - left > 1)
    {
        size_t middle = std::midpoint(left, right);
        if (data[middle] <= value)
        {
            left = middle;
        }
        else
        {
            right = middle;
        }
    }
    return left;
}
\end{minted}
Формально данный отрывок кода называется \textit{определением шаблона функции}. Выражение \inlcpp{T} в этом коде называют \textit{аргументом шаблона}, первую строчку \textit{заголовком шаблона}, а остальной код \textit{телом шаблона}. Отметим, что вместо ключевого слова \inlcpp{class} в первой строчке возможно использование ключевого слова \inlcpp{typename}. Эти ключевые абсолютно эквивалентны в контексте аргументов шаблона и не имеют отношения к классам как к фиче языка C++. Продолжая аналогию с макросами, мы можем явно попросить компилятор создать функцию по написанному нами шаблону:
\begin{minted}{c++}
template size_t binarySearch<int>(
    std::span<int const> data, int value);
\end{minted}
Понимать эту строчку следует как подстановку вместо неё тела шаблона с аргументами заменёнными на указанные в ней. В данном случае все вхождения имени \inlcpp{T} заменяется на \inlcpp{int}. Формально процесс подстановки аргументов в шаблон и получение настоящей функции языка C++ называется \textit{инстанциацией}. Результат процесса инстанциации, то есть получаемая в результате функция, называется \textit{специализацией}. Само выражение написанное выше называют \textit{явной инстанциацией} (причина такого названия станет ясна ниже). Имя функции, сгенерированной этой явной инстанциацией, выглядит как \inlcpp{binarySearch<int>}, а вызов соответственно как \inlcpp{binarySearch<int>(data, 42)}.

Однако, явные инстанциации -- весьма редко используемый на практике инструмент. В отличии от макросов, компилятор способен сам отслеживать с какими аргументами необходимо инстанцировать шаблон. Можно считать, что в недрах компилятора для каждого шаблона функции хранится таблица соответствий набора аргументов определению получаемой в результате функции. Таблица заполняется лениво по мере необходимости, то есть встретив в коде вызов функции \inlcpp{binarySearch<U>}, где \inlcpp{U} -- какой-то конкретный тип, компилятор либо использует уже имеющееся определение функции из таблицы, либо предварительно сгенерирует новое и заполнит им ячейку в таблице. Этот процесс формально называется \textit{неявной инстанциацией}, или просто \textit{инстанциацией}.

Обратим внимание несколько важных деталей о взаимодействии шаблонов функций и структуры многофайловых проектов. Определение шаблона функции не является определением функции, а значит на него не распростроняется one definition rule. Следовательно мы можем помещать определения шаблонов как и в заголовочных (.hpp) файлах, так и в компилируемых (.cpp) файлах. Однако есть веская причина почти всегда помещать шаблоны в заголовочных файлах: для инстанциации шаблона необходимо иметь полное тело шаблона в текущем файле. Из этого вытекает один из главных недостатков шаблонов. Так как каждая единица трансляции компилируется из соответствующего .cpp файла независимо\footnote{Это позволяет системам сборки запускать несколько процессов компиляции разных файлов параллельно на многоядерных системах}, у компилятора нет выбора кроме как заново инстанцировать шаблон в каждой единице трансляции, заново компилировать полученную инстанциацию в бинарный код и вкладывать его в каждый получаемый объектный файл. На практике это приводит к <<раздуванию>> размера итогового бинарного файла программы и увеличению времени компиляции. Как мы увидим в следующем разделе, первая из этих проблем уже не совсем актуальна.

Узнав про неявную инстанциацию у читателя мог возникнуть закономерный вопрос: а зачем вообще в языке C++ есть механизм явной инстанциации? Перед тем как ответить на этот вопрос, нам понадобится познакомиться с новым понятием, \textit{объявлением шаблона функции}:
\begin{minted}{c++}
template<class T>
size_t binarySearch(std::span<T const> data, T value);
\end{minted}
Если инстанциация определения шаблона функции с конкретными аргументами приводит к определению функций, инстанциация объявления шаблона функции приводит к объявлению функций. Это значит, попытавшись инстанциировать шаблон функции имея только объявление шаблона, но не определение шаблона, объектный файл скомпилируется, но программа в целом не слинкуется, если в каком-то другом объектном файле не было инстанцировано определение. На практике возможность отдельно определять и объявлять шаблоны функций используется двумя способами. 

Во-первых, традиционно каждая пара .cpp и .hpp файлов отвечает одному мини-модулю программы, и в заголовочном файле принято оставлять исключительно публичное API этого модуля. Это позволяет читающему код легко использовать имеющийся код не влезая в детали имплементации, а также не компилировать заново все использующие заголовочный файл модули при изменении деталей имплементации. Шаблоны функций же нарушают эту традицию, у нас нет выбора кроме как помещать имплементацию (определение) прямо в заголовочный файл, иначе использующий наш модуль код не сможет инстанцировать шаблон. С точки зрения механики компиляции с этим поделать ничего нельзя, однако с точки зрения синтаксиса и удобства чтения кода пользователем мы можем улучшить ситуацию использовав объявления шаблонов следующим образом:
\begin{minted}{c++}
// Файл binarySearch.hpp
#pragma once

#include <span>
#include <cstddef>

template<class T>
size_t binarySearch(std::span<T const> data, T value);

#include "binarySearch.ipp"

// Файл binarySearch.ipp

template<class T>
size_t binarySearch(std::span<T const> data, T value)
{
    ...
}
\end{minted}
Мы разделили заголовочный файл на 2 половины: файл .hpp (header) с объявлениями шаблонов и файл .ipp (implementation) с определениями шаблонов, где первый подключает второй в свой конец. Таким образом пользователю чтобы использовать наш модуль достаточно прочитать содержимое файла .hpp, не обязательно пролистывать весь код чтобы узнать какие функции есть в модуле. На тривиальном примере из одной функции это звучит слегка абсурдно, но при написании крупных модулей с десятками функций эта техника сильно помогает облегчить жизнь читающего код.

Во-вторых, есть ситуации, когда шаблон предполагается использовать с очень ограниченным семейством типов, например только с примитивными числовыми типами. В этой ситуации мы можем пойти ещё дальше и полностью спрятать тело шаблона от пользователя в .cpp файл, инстанцировав явно его для необходимых нам аргументов.
\begin{minted}{c++}
// Файл binarySearch.hpp
#pragma once

#include <span>
#include <cstddef>

template<class T>
size_t binarySearch(std::span<T const> data, T value);

// Файл binarySearch.cpp

template<class T>
size_t binarySearch(std::span<T const> data, T value)
{
    ...
}

template size_t binarySearch<int>(
    std::span<int const> data, int value);
template size_t binarySearch<float>(
    std::span<float const> data, float value);
\end{minted}
В случае с двоичным поиском вероятно такое разделение излишне, ведь пользователь может захотеть использовать его со своими типами данных, но время от времени эта техника действительно всплывает на практике. Именно для неё в язык C++ и были добавлены явные инстанциации.

Рассмотрим ещё одну возможность шаблонов функций, \textit{явные специализации}\footnote{Вообще говоря официальное название -- \textit{явная полная специализация}}. Напомним, что специализацией называется функция результат инстанциации шаблона. Предположим, что наша целевая платформа поддерживает специальную функцию \inlcpp{fastIntSearch}, способную очень быстро найти индекс целого числа в массиве размера меньше, скажем, 16 элементов. Хотелось бы, чтобы наша функция \inlcpp{binarySearch} использовала эту инструкцию как только область поиска стала достаточно маленькой, но конечно же использовать её можно исключительно для типа данных \inlcpp{int}. Как нам изменить код специализации \inlcpp{binarySearch<int>} не поменяв код любых других специализаций? Ровно эту функцию выполняют явные специализации:
\begin{minted}{c++}
template<>
size_t binarySearch<int>(std::span<int const> data, int value)
{
    size_t left = 0;
    size_t right = data.size();
    while (right - left > 16)
    {
        size_t middle = std::midpoint(left, right);
        if (data[middle] <= value)
        {
            left = middle;
        }
        else
        {
            right = middle;
        }
    }
    return fastIntSearch(data.subspan(left, right - left), value);
}
\end{minted}
Если в области видимости на момент использования \inlcpp{binarySearch<int>} содержится и основное определение шаблона, и эта явная специализация, то для вызова будет использована явная специализация. Стоит обратить внимание, что на момент объявления явной специализации шаблон функции уже должен быть объявлен. Также заметим, что явная специализация является обычным определением функции, а поэтому может быть разделено на объявление и определение, где первое следует помещать в заголовочный файл, а второе в .cpp-файл:
\begin{minted}{c++}
// binarySearch.hpp
...
template<>
size_t binarySearch<int>(std::span<int const> data, int value);

// binarySearch.cpp
...
template<>
size_t binarySearch<int>(std::span<int const> data, int value)
{
    ...
}
\end{minted}
Если поместить определение явной специализации в заголовочный файл, необходимо пометить её как \inlcpp{inline}, иначе мы нарушим ODR\footnote{One definition rule}.

В заключение раздела упомянем о \textit{выведении типов}. До сих пор мы явно указывали шаблонные аргументы для специализаций в момент вызова или специализации. Работая с более сложными шаблонами необходимость указывать эти аргументы быстро становится обременяющей, поэтому в C++ был добавлен достаточно сложный механизм автоматического выведения типа шаблонных аргументов. Детали работы этого механизма будут рассмотрены в одной из следующих глав, а сейчас лишь скажем, что в большом количестве случаев указывать шаблонные аргументы не обязательно:
\begin{minted}{c++}
void foo()
{
    std::vector<int> data{...};
    int value = 42;
    // Тип T автоматически будет выведен как int
    // на основании типа аргумента value.
    binarySearch(data, value);
}

// Аналогично для явных специализаций 
template<>
size_t binarySearch(std::span<int const> data, int value)
{
    ...
}
\end{minted}

\subsection*{Упражнения}
\begin{itemize}
\item Задумайтесь, что произойдёт, если попытаться инстанцировать шаблон binarySearch с аргументом типа \inlcpp{Person}, описанным ниже. Попробуйте написать это. Что нужно сделать, чтобы функция искала человека по возрасту? Легко ли было это понять?
\begin{minted}{c++}
struct Person
{
    std::string name;
    uint32_t age;
};
\end{minted}
\item Напишите шаблон функции \inlcpp{pairLess} от одного аргумента с типом произвольной специализации \inlcpp{std::pair}, возвращающую \inlcpp{true} если первый элемент меньше второго, а иначе \inlcpp{false}. Обратите внимание, типы первого и второго элемента пары могут отличаться. О синтаксисе шаблона с несколькими аргументами читателю предлагается догадаться самостоятельно.
\item Что произойдёт, если забыть объявить явную специализацию в заголовочном файле?
\item Рассмотрим следующий код
\begin{minted}{c++}
// Часть интерфейса библиотеки
struct GraphicsState
{
    bool enableWireframe;
    std::string noiseTextureName;
    std::optional<PipelineDescription> pipelineDescription;
    ...
};

// Часть имплементации библиотеки
struct InternalGraphicsState
{
    bool enableWireframe{false};
    TexturePtr noiseTexture;
    std::optional<PipelineDescription> pipelineDescription;
    ...
};

InternalGraphicsState covertState(
    const GraphicsState& state)
{
    InternalGraphicsState result;
    result.enableWireframe = state.enableWireframe;
    if (!noiseTextureName.empty())
    {
        result.noiseTexture =
            getTexture(state.noiseTextureName);
    }
    result.pipelineDescription = state.pipelineDescription;

    ...

    return result;
}

struct InternalGraphicsStateDelta
{
    // std::nullopt означает отсутствие изменения
    std::optional<bool> enableWireframe;
    std::optional<Texture> noiseTexture;
    std::optional<Pipeline> pipeline;
    ...
};

InternalGraphicsStateDelta calculateDelta(
    const InternalGraphicsState& before,
    const InternalGraphicsState& after)
{
    InternalGraphicsStateDelta result;
    if (before.enableWireframe
        != after.enableWireframe)
    {
        result.enableWireframe
            = after.enableWireframe;
    }

    if (before.noiseTexture !=
        after.noiseTexture)
    {
        result.noiseTexture
            = after.noiseTexture;
    }

    if (before.pipelineDescription
        != after.pipelineDescription)
    {
        result.pipeline = createPipeline(
            after.pipelineDescription)
    }

    ...

    return result;
}
\end{minted}
Используя шаблоны функций и возможно макросы, избавьте код от копипасты логики и сделайте добавление новых полей-состояний в эти структуры более безболезненным. Для поддержки "особенных" полей воспользуйтесь явной специализацией шаблонов функций. 
\end{itemize}

\section{Шаблоны методов}

Помимо "свободных" функций в языке C++ поддерживаются связанные с классом функции, называемые \textit{методами}. Методы также можно генерировать при помощи шаблонов:
\begin{minted}{c++}
class Any
{
public:
    template<class T>
    T* castTo()
    {
        return reinterpret_cast<T*>(data_);
    }
private:
    void* data_;
};
\end{minted}
Определение шаблонов методов также можно отделять от объявления:
\begin{minted}{c++}
template<class T>
T* Any::castTo() {...}
\end{minted}
Со специализациями же ест одна тонка деталь, согласно стандарту их необходимо помещать вне объявления класса:
\begin{minted}{c++}
// Объявление специализации
template<>
int* Any::castTo<int>();
template<>
// Определение специализации
int* Any::castTo<int>() {...}
\end{minted}
Но компилятор MSVC позволяет помещать их и внутри самого класса. Использовать эту возможность разумеется не стоит, так как это делает код платформозависимым.

\section{Шаблоны глобальных переменных}

Искушённый знанием языка C читатель знает, что в объектном файле скомпилированной программы бывает два вида символов: функции и переменные. Если C++ разрешает генерировать символы функций из шаблонов, было бы странно запрещать генерировать символы переменных. И действительно, язык поддерживает \textit{шаблоны переменных}, однако за исключением упомянутого в следующем разделе частного случая, используются они сильно реже шаблонов функций.

Синтаксис шаблонов переменных абсолютно аналогичен синтаксису шаблонов функций, как и набор языковых средств связанных с ним.
\begin{minted}{c++}
// Объявление шаблона переменной
template<class T>
extern std::vector<T> globalStorage;

// Определение шаблона переменной
template<class T>
std::vector<T> globalStorage;

// Явная инстанциация
template std::vector<int> globalStorage<int>;

// Явная специализация
template<>
NotStdVector<bool> globalStorage<bool>;
\end{minted}

Как можно понять из примера, в чистом виде шаблоны глобальных переменных в основном используются в качестве параметризированного глобального хранилища в процедурном коде.

Ранее уже упоминалось, что шаблоны повторно инстанцируются в разных объектных файлах, в результате чего символ специализации может содержаться в нескольких объектных файлах. Для функций эта особенность не страшна, так как соответствующий специализации символ указывает на неизменяемый код функции. Для переменных же возникает опасение: если одной переменной соответствует несколько символов с разным хранилищем, то на самом деле мы получим не одну переменную, а несколько независимо меняющихся переменных. Но на самом деле опасение напрасно, в результате статической линковки и для функций и для переменных будет оставлен только один их экземпляр в итоговом бинарном файле. На типичных платформах достигается это за счёт механизма \textit{слабых} символов. При компиляции обычных функций и переменных в единице трансляции генерируются сильные символы. Если при линковке сильный символ с одинаковым названием содержится в нескольких единицах трансляции, линковщик выдаст ошибку. В случае же функций и переменных, являющихся специализациями шаблонов, либо помеченных как inline, компилятор генерирует слабые символы. Встретив несколько слабых символов с одинаковым именем, линковщик выкинет все из них кроме одного. Таким образом в итоговой программе будет содержаться лишь один экземпляр каждой функции и переменной.

Стоит отметить, что с точки зрения стандарта C++ никаких символов не существует. Линковка шаблонов описана куда более абстрактным языком, и частенько оказывается оторванным от практики. В крупных проектах итоговая программа не редко разбита на множество динамических библиотек. Например Unreal Engine разбит на множество dll-файлов для возможности hot-reload отдельных модулей без полной перезагрузки редактора, а в использующих GNU core utilities операционных системах б\'{о}льшая часть функционала вынесена в so-библиотеки для экономии памяти и удобства обновления отдельных модулей системы. Отличие динамических библиотек от статических в том, что нахождение расположения символов происходит не в момент компиляции программы, а прямо в процессе работы, через обращение к линковщику операционной системы. Таким образом в момент компиляции символы из статических библиотек копируются в итоговый бинарный файл нашей программы, потенциально выкидывая дубликаты слабых символов, а символы из динамических библиотек лишь порождают "заглушки" помогающие программе загружать необходимые символы по мере нужды. К сожалению, при загрузке символов в рантайме не происходит дедупликации слабых символов, а поэтому одна и та же специализация шаблонной переменной из разных so-файлов будет на самом деле ссылаться на разную память, иначе говоря это будут две разные, независимые переменные. По этой причине стоит избегать шаблонов переменных при проектировании публичных интерфейсов библиотек.
\footnote{Более подробно о механизме динамической линковки можно почитать по \href{https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html}{ссылке}.}


\section{constexpr, consteval, constinit}
Начиная с C++11 в языке по чуть-чуть начали появляться новые инструменты метапрограммирования, выступающие и альтернативой и дополнением к шаблонам: титулярные ключевые слова. В общем и целом все они предназначены для переноса выполнения некоторых вычислений из рантайма в компайлтайм. Рассмотрим следующий пример.
\begin{minted}{c++}
enum class LogLevel
{
    Info, Warning, Error, Fatal
};

std::unordered_map<LogLevel, std::string> logLevelStrings
    {
        {Color::Info, "INFO"},
        {Color::Warning, "WARNING"},
        ...
    };

...

#define LOG_WARN(msg) \
std::printf("[%s] (%s:%d): %s",
    logLevelStrings.at(LogLevel::Warning),
    __FILE, __LINE__,
    msg);
\end{minted}
Подобный код для логирования можно встретить во многих промышленных проектах. Чем плох наш вариант? Обратить внимание стоит на поиск элемента в \inlcpp{std::unordered_map}. Он хоть и работает за $O(1)$, но всё равно не бесплатен. Почему мы платим за поиск известного нам во время компиляции элемента в хеш-таблице временем в рантайме? Конечно же можно полностью отказаться от использования таблицы и вписать нужную строку прямо в макрос, но это решение не расширяется на большее число различной инфраструктуры, связанной с логированием. Мы быстро начнём копировать эту строку в разных местах и в итоге придём к нарушению правила одного источника истины\footnote{SPOT, single point of truth}. Вместо этого попробуем заменить таблицу на функцию:
\begin{minted}{c++}
enum class LogLevel
{
    Info, Warning, Error, Fatal
};

const char* logLevelToString(LogLevel level)
{
    switch (level)
    {
        case LogLevel::Info: return "INFO";
        ...
    }
    return "?";
}
\end{minted}
Это уже чуть лучше, прыжок в \inlcpp{switch} скорее всего будет дешевле вычисления хеш-функции. Однако при вызове нашей функции мы всё ещё будет нагружать процессор лишней работой: если мы знаем на момент компиляции аргумент \inlcpp{level}, то мы можем знать и результат функции. Именно эту проблему решает ключевое слово \inlcpp{consteval}. Дописав его перед сигнатурой функции мы \textbf{запретим} компилятору компилировать эту функцию в традиционном смысле этого слова, и разрешим лишь только вычислять её результат \textit{прямо во время компиляции}:
\begin{minted}{c++}
consteval const char* logLevelToString(LogLevel level) {...}

// ...

int main(int argc, char** argv)
{
    int level = 0;
    std::cin >> level;
    // Ошибка компиляции: LogLevel{level}
    // не является константным выражением
    std::cout << logLevelToString(LogLevel{level});
    // OK! Всё выражение после `<<` будет
    // вычислено в момент компиляции, в
    // итоговом бинарном файле будет лишь вызов
    // `operator<<(std::cout, "FATAL")`.
    std::cout << logLevelToString(LogLevel::Fatal);
}
\end{minted}
В случае же если мы не хотим запрещать вычисление функции в рантайме, но хотим чтобы компилятор вычислял результат вызова функции во время компиляции когда это возможно, следует использовать ключевое слово \inlcpp{constexpr} вместо \inlcpp{consteval}. Подчеркнём это дважды: для функций \inlcpp{consteval} означает "всегда в компайлтайме", а \inlcpp{constexpr} означает "можно в компайлтайме". Обратим внимание на понятие \textit{константного выражения}, упомянутое в примере выше. Для наших целей достаточно интуитивного его понимания как \textit{выражения, которое можно вычислить в момент компиляции}, более точное определение содержится в стандарте. Примерами константных выражений являются все литералы и вызовы constexpr и consteval функций от них. Контрпримером же является переменная \inlcpp{int level} в примере выше, так как в неё можно поместить данные, известные только в рантайме. Однако константные переменные могут как быть так и не быть константными выражениями в зависимости от константности выражения которым они инициализированы.

Ключевое слово \inlcpp{constexpr} можно также использовать с переменными. К типу таких переменных автоматически добавляется ключевое слово \inlcpp{const}, а выражение которым инициализируется такая переменная может быть только константным. Таким образом значение constexpr-переменной всегда известно во время компиляции и не может быть изменено в рантайме. Более того, компилятор по возможности будет избегать включения такой переменной как символа в скомпилированную программу.
\begin{minted}{c++}
constexpr size_t DATA_AMOUNT = 42;
...
// DATA_AMOUNT скорее всего не породит символа
std::array<int, DATA_AMOUNT> data;

...

// Обратите внимание, тип MESSAGE --
// const char* const, то есть константный
// указатель на константный char.
constexpr const char* MESSAGE = "Fatal error!";
...
// MESSAGE породит символ в разделе rodata,
// в котором будет сохранена соответствующая строка
std::cout << MESSAGE;
\end{minted}

%...

В заключение раздела поговорим об ограничениях constexpr функций и переменных. На момент добавления этих возможностей в язык ограничений было очень много: нельзя было выделять память на куче, использовать циклы и условия, и многое другое. Однако с каждой следующей версией стандарта ограничений становится всё меньше, поэтому при написании constexpr-функций не стоит намеренно ограничивать себя в использовании языковых инструментов, а для сложных случаев всегда можно посмотреть точные требования в \href{https://en.cppreference.com/w/cpp/language/constexpr#:~:text=A%20constexpr%20function%20must%20satisfy%20the%20following%20requirements%3A}{справочнике}.

\section{Констрейнты и концепты}

\chapter{Введение в шаблоны}
\section{Базовые понятия}
Шаблоном, согласно стандарту, называют отрывок кода специального вида\footnote{Вид этот определён сложной к прочтению формальной грамматикой.}, задающий семейство классов, функций или переменных, алиас\footnote{Алиасом называют имя, заданное посредством ключевого слова \inlcpp{using}.} на семейство типов, либо концепт. Прочитав это определение представить в голове что такое шаблон решительно невозможно, поэтому постараемся распутать его, пожертвовав в процессе точностью в угоду простоте, и выработать ментальную модель, пригодную для использования при написании кода.

Итак, не отступая далеко от <<официального>> определения, шаблоном мы действительно будем называть отрывок кода, состоящий из двух частей: заголовка и тела. Заголовок обязан выглядеть как \inlcpp{template<...>}, где на месте \inlcpp{...} перечисляются через запятую так называемые \textit{аргументы шаблона}, подробнее о которых будет ниже. Тело же обязано быть \textit{определением} или \textit{объявлением} некоторой сущности языка C++, например класса, структуры, функции или глобальной переменной. Незамедлительно перейдём к синтаксическим примерам, не обременяя себя семантикой происходящего:
\begin{minted}{c++}
// Шаблон структуры от двух аргументов-типов
template<class T, class U>
struct Pair
{
    T first;
    U second;
};

// Шаблон структуры от одного аргумента-не-типа
template<int Size>
struct ArrayOfBools
{
    bool values[Size];
};

// Шаблон алиаса
template<class U>
using SamePair = Pair<U, U>;

// Шаблон объявления функции
template<class T>
T square(T value);

// Шаблон определения функции
template<class T>
T square(T value)
{
    return value*value;
};
\end{minted}
Из примера видно, что в качестве аргумента шаблона может выступать как типы, так и значения (но некоторыми ограничениями). В первом случае используется синтаксис \inlcpp{class ArgumentName} или эквивалентный ему \inlcpp{typename ArgumentName}. Во втором случае синтаксис аналогичен обычным функциям.

Теперь, имея представление о том, как выглядят шаблоны в коде, начнём разбирать их семантику. Для этого нам потребуется переосмыслить понимание системы типов C++.

Что есть тип? Согласно теории типов, это не что иное, как \textit{множество его возможных значений}\footnote{Это не правда}. Таким образом тип \inlcpp{bool} не отличим от множества $\{\mathrm{true}, \mathrm{false}\}$, а тип \inlcpp{uint32_t} не отличим от $\left[0, 2^{32}\right) \cap \mathbb{Z}$. Структуры и кортежи же не отличимы от декартовых произведений, например
\begin{minted}{c++}
struct Person
{
    uint32_t age;
    float height;
};
\end{minted}
эквивалентно множеству $\mathrm{uint32\_t} \times \mathrm{float}$. Аналогичное справедливо про \inlcpp{std::pair} и \inlcpp{std::tuple}. Двойственная к произведению конструкция -- непересекающееся объединение, обозначаемое как $A \sqcup B$, которому эквивалентны \inlcpp{union} и \inlcpp{std::variant}.

Функции языка C++ в нашей интерпретации эквивалентны обычным математическим функциям, отображающим значения одного типа в значения другого типа. Однако так мы ограничиваемся рассмотрением исключительно \textit{чистых} функций, то есть возвращающих один и тот же результат при одинаковых входных данных. Чистыми не являются, например, функции \inlcpp{std::scanf} и \inlcpp{std::rand}.

Наконец рассмотрим множество $\mathrm{Type}$, содержащее в себе все возможные типы. Тогда шаблон класса/структуры является частичной функцией $Type \to Type$. 



